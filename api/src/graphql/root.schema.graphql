scalar JSON  ## use this only for development, but never depend on values of this type

type Garden {
    _id: ID!
    gardenId: ID!
    label: String!
    settings: GardenSettings @relationship(type: "of", direction: IN)
}

type GardenSettings {
    _id: ID!
    garden: Garden! @relationship(type: "of", direction: OUT)
    name: String
    shortDescription: String
    infoPageMarkdown: String
    homepageUrl: String
    logoUrl: String
    location: Point
}

type User {
    _id: ID!
    id: String!
    label: String!
    neo4jImportId: String!
    type: String!
    assigned: [WateringTask!]! @relationship(type: "assigned", direction: OUT)
    available: [WateringTask!]! @relationship(type: "available", direction: OUT)
    changerequests_requested_by: [ChangeRequest!]! @relationship(type: "requested_by", direction: IN)
    changerequests_requested_to: [ChangeRequest!]! @relationship(type: "requested_to", direction: IN)
    logevents_triggered_by: [LogEvent!]! @relationship(type: "triggered_by", direction: IN)
}

type WateringTask {
    _id: ID!
    date: Date!
    done: Boolean
    neo4jImportId: String!
    type: String!
    label: String
    users_assigned: [User!]! @relationship(type: "assigned", direction: IN)
    changerequests_requested_for: [ChangeRequest!]! @relationship(type: "requested_for", direction: IN)
    changerequests_requested_new_task: [ChangeRequest!]! @relationship(type: "requested_new_task", direction: IN)
    logevents_refers_to: [LogEvent!]! @relationship(type: "refers_to", direction: IN)
    users_available: [User!]! @relationship(type: "available", direction: IN)
    wateringperiod: [WateringPeriod!]! @relationship(type: "within", direction: OUT)
}

type WateringPeriod {
    _id: ID!
    from: Date!
    till: Date!
    at: Garden @relationship(type: "at", direction: OUT)
    wateringtasks: [WateringTask!]! @relationship(type: "within", direction: IN)
    hasUsersAssigned: Boolean @cypher(statement: "MATCH (t:WateringTask)-[:within]->(this) RETURN (EXISTS((t)-[:assigned]-(:User)))")
}

type ChangeRequest {
    _id: ID!
    label: String!
    neo4jImportId: String!
    type: String!
    requested_by: [User!]! @relationship(type: "requested_by", direction: OUT)
    requested_for: [WateringTask!]! @relationship(type: "requested_for", direction: OUT)
    requested_to: [User!]! @relationship(type: "requested_to", direction: OUT)
    requested_new_task: [WateringTask!]! @relationship(type: "requested_new_task", direction: OUT)
}

type LogEvent {
    _id: ID!
    date: String!
    label: String!
    neo4jImportId: String!
    type: String!
    triggered_by: [User!]! @relationship(type: "triggered_by", direction: OUT)
    refers_to: [WateringTask!]! @relationship(type: "refers_to", direction: OUT)
}


interface GeoShape {
    shapeId: ID! @id
    points: [Point]!
    belongs_to: [GardenLayer!]! @relationship(type: "belongs_to", direction: OUT)
    feature: GardenFeature @relationship(type: "has_shape", direction: IN)
}

type GardenLayer {
    layerId: ID! @id
    name: String!
    date: Date
    at: Garden @relationship(type: "at", direction: OUT)
    has_shape: [GeoShape!]!  @relationship(type: "belongs_to", direction: IN)
}


type PolygonShape {
    shapeId: ID! @id
    points: [Point]!
    belongs_to: [GardenLayer!]! @relationship(type: "belongs_to", direction: OUT)
    startPoint: Point
    feature: GardenFeature @relationship(type: "has_shape", direction: IN)
}

extend type PolygonShape implements GeoShape

type MarkerShape {
    shapeId: ID! @id
    points: [Point]!
    belongs_to: [GardenLayer!]! @relationship(type: "belongs_to", direction: OUT)
    icon: String!
    point: Point!
    feature: GardenFeature @relationship(type: "has_shape", direction: IN)
}
extend type MarkerShape implements GeoShape

type GardenFeature {
    featureId: ID! @id
    shape: [GeoShape!]! @relationship(type: "has_shape", direction: OUT )
    infoText: String
    label: String!
    featureType: String!
    plants: [String]!
    contains: [Container!]! @relationship(type: "stored_in", direction: IN)
}

type Container {
    containerType: String!
    storageLocation: [GardenFeature!]! @relationship(type: "stored_in", direction: OUT)
}

interface PositiveNeighborhood  @relationshipProperties {
    weight: Int
}
interface CropRotation  @relationshipProperties {
    weight: Int
}

type Category {
    label: String!
    description: String
    parentCategory: Category @relationship(type: "parent", direction: IN)
    childCategories: [Category!]! @relationship(type: "parent", direction: OUT)
    species: [PlantSpecies!]! @relationship(type: "has_category", direction: IN)
}

type PlantSpecies {
    label: String!
    description: String
    infoText: String
    icon: String
    categories: [Category!]! @relationship(type: "has_category", direction: OUT)
    positiveNeighborhood: [PlantSpecies!]! @relationship(type: "positive_neighbor", direction: OUT, queryDirection: DEFAULT_DIRECTED, properties: "PositiveNeighborhood")
    cropRotationFactor: [PlantSpecies!]! @relationship(type: "crop_rotation_factor", direction: OUT, queryDirection: DEFAULT_DIRECTED, properties: "CropRotation")
    varieties: [PlantVariety!]! @relationship(type: "part_of_species", direction: IN)
}

type PlantVariety {
    label: String!
    description: String
    species: PlantSpecies! @relationship(type: "part_of_species", direction: OUT)
    infoText: String
    icon: String

}

type Seed {
    variety: PlantVariety!
    amount: Int
    unit: String
    containedIn: Container @relationship(type: "contains", direction: IN)
}



